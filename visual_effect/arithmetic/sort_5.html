<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>插入排序-折半插入排序</title>
</head>
<body>
	<p>折半插入排序是直接插入排序的升级版. 鉴于插入排序第一部分为已排好序的数组, 我们不必按顺序依次寻找插入点, 只需比较它们的中间值与待插入元素的大小即可.</p>
	<p>Tips: 同直接插入排序类似, 折半插入排序每次交换的是相邻的且值为不同的元素, 它并不会改变值相同的元素之间的顺序. 因此它是稳定的.</p>
	<ul>
		<li>算法基本思想是:</li>
		<li>取0 ~ i-1的中间点( m = (i-1)>>1 ), array[i] 与 array[m] 进行比较, 若array[i] < array[m] , 则说明待插入的元素array[i] 应该处于数组的 0 ~ m 索引之间; 反之, 则说明它应该处于数组的 m ~ i-1 索引之间.</li>
		<li>重复步骤1, 每次缩小一半的查找范围, 直至找到插入的位置.</li>
		<li>将数组中插入位置之后的元素全部后移一位.</li>
		<li>在指定位置插入第 i 个元素.</li>
		<li>ps:注: x>>1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x>>1 == parseInt(x/2) .</li>
	</ul>
	<script type="text/javascript">
		function binaryInsertionSort(array){
			var current,i,j,low,high,m;
			for(i=1;i<array.length;i++){
				low=0;
				high=i-1;
				current=array[i];
				while(low<=high){
					m=(low+high)>>1;
					if(array[i]>=array[m]){
						low=m+1;
					}else{
						high=m-1;
					}
				}
				for(j=i;j>low;j--){
					array[j]=array[j-1];
				}
				array[low]=current;
			}
			return array;
		}
	</script>
	<p>虽然折半插入排序明显减少了查询的次数, 但是数组元素移动的次数却没有改变. 它们的时间复杂度都是O(n²).</p>
</body>
</html>